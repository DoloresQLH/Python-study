# exec和eval现在都是函数，但exec以前是一种语句，而eval
# 与它紧密相关。
# 1. exec
# 函数exec将字符串作为代码执行。
exec("print('Hello, world!')")        #Hello, world!
# 然而，调用函数exec时只给它提供一个参数绝非好事。在大多数情况下，还应向它传递一个
# 命名空间——用于放置变量的地方；否则代码将污染你的命名空间，即修改你的变量。例如，假
# 设代码使用了名称sqrt，结果将如何呢？
from math import sqrt
# exec("sqrt = 1")
# print(sqrt(4))                    #TypeError: 'int' object is not callable
# 实际上，可向exec提供两个命名空间：一个全局的和一个局部的。提供的全局命名空间必须是字典，而提供的局
# 部命名空间可以是任何映射。这一点也适用于eval。
scope = {}
exec("sqrt =1",scope)
print(sqrt(4))
# 2. eval
# eval是一个类似于exec的内置函数。exec执行一系列Python语句，而eval计算用字符串表示
# 的Python表达式的值，并返回结果（exec什么都不返回，因为它本身是条语句）。例如，你可使
# 用如下代码来创建一个Python计算器：
print(eval(input("Enter an arithmetic expression: ")))
scope1 = {}
scope['x'] = 2
scope['y'] = 3
print(eval('x * y', scope))



# 小结
# 本章介绍了多种语句。
#  打印语句：你可使用print语句来打印多个用逗号分隔的值。如果print语句以逗号结尾，
# 后续print语句将在当前行接着打印。
#  导入语句：有时候，你不喜欢要导入的函数的名称——可能是因为你已将这个名称用作
# 他用。在这种情况下，可使用import ... as ...语句在本地重命名函数。
#  赋值语句：通过使用奇妙的序列解包和链式赋值，可同时给多个变量赋值；而通过使用
# 增强赋值，可就地修改变量。
#  代码块：代码块用于通过缩进将语句编组。代码块可用于条件语句和循环中，还可用于
# 函数和类定义中（这将在本书后面介绍）。
#  条件语句：条件语句根据条件（布尔表达式）决定是否执行后续代码块。通过使用if/elif/
# else，可将多个条件语句组合起来。条件语句的一个变种是条件表达式，如a if b else c。  断言：断言断定某件事（一个布尔表达式）为真，可包含说明为何必须如此的字符串。
# 如果指定的表达式为假，断言将导致程序停止执行（或引发第8章将介绍的异常）。最好
# 尽早将错误揪出来，免得它潜藏在程序中，直到带来麻烦。
#  循环：你可针对序列中的每个元素（如特定范围内的每个数）执行代码块，也可在条件
# 为真时反复执行代码块。要跳过代码块中余下的代码，直接进入下一次迭代，可使用
# continue语句；要跳出循环，可使用break语句。另外，你还可在循环末尾添加一个else
# 子句，它将在没有执行循环中的任何break语句时执行。
#  推导：推导并不是语句，而是表达式。它们看起来很像循环，因此我将它们放在循环中
# 讨论。通过列表推导，可从既有列表创建出新列表，这是通过对列表元素调用函数、剔
# 除不想要的函数等实现的。推导功能强大，但在很多情况下，使用普通循环和条件语句
# 也可完成任务，且代码的可读性可能更高。使用类似于列表推导的表达式可创建出字典。
#  pass、del、exec和eval：pass语句什么都不做，但适合用作占位符。del语句用于删除变
# 量或数据结构的成员，但不能用于删除值。函数exec用于将字符串作为Python程序执行。
# 函数eval计算用字符串表示的表达式并返回结果。
#  本章介绍的新函数
# 函 数 描 述
# chr(n) 返回一个字符串，其中只包含一个字符，这个字符对应于传入的顺序值n（0 ≤
# n < 256）
# eval(source[,globals[,locals]]) 计算并返回字符串表示的表达式的结果
# exec(source[, globals[, locals]]) 将字符串作为语句执行
# enumerate(seq) 生成可迭代的索引值对
# ord(c) 接受一个只包含一个字符的字符串，并返回这个字符的顺序值（一个整数）
# range([start,] stop[, step]) 创建一个由整数组成的列表
# reversed(seq) 按相反的顺序返回seq中的值，以便用于迭代
# sorted(seq[,cmp][,key][,reverse]) 返回一个列表，其中包含seq中的所有值且这些值是经过排序的
# xrange([start,] stop[, step]) 创建一个用于迭代的xrange对象
# zip(seq1, seq2,...) 创建一个适合用于并行迭代的新序列